---
layout: ../../layouts/post.astro
title: Задание №3
description: Тестирование корзины и оплат для исключения дублирования.
---

### Тестирование
Представьте, что разработчик выкатил новую версию корзины. При оплате клиент жалуется: «У меня заказ списался дважды».

Задача:

-Опишите, как бы вы протестировали корзину и оплату, чтобы воспроизвести или исключить эту проблему.
-Составьте список шагов (чек-лист), по которому можно проверить корректность работы корзины и платежей.

---

## Краткая стратегия

1. **Сначала — собрать факты** (ID заказа(ов), время, user_id, платежный transaction_id у PSP, лог запросов).
2. **Диагностика** — выяснить, где произошло дублирование: в PSP (две транзакции) или только в нашей системе (две записи/заказа при одной транзакции).
3. **Репродукция на staging** — эмулировать все подозрительные сценарии: двойной click, таймауты, повторные вебхуки, cron/планировщик, mixed-cart, 3DS.
4. **Закрепление защит** — добавить/проверить идемпотентность, блокировки, обработку повторных webhook'ов и защиту UI.

---

## Что собрать в первую очередь (не теряем время)

* Точные данные от пользователя: Woo order ID(s), дата/время, последние 4 цифры карты (если пользователь дал), email/телефон.
* Доступ к PSP dashboard — найти транзакции по времени/карте. Нужны transaction_id, status, платёжный референс.
* Логи сервера / приложений (webserver, php-fpm, plugin logs) в диапазоне ±5 минут от события.
* Webhook logs (входящие на `/webhooks/psp/*`) — есть ли повторные вызовы, ретраи, 5xx ответы.
* Логи интеграции с RetailCRM (если связано).
* Дамп записей таблиц: `wp_posts` (orders), `wp_postmeta` (payment meta), таблицы плагина платежей/subscriptions, таблица платежей PSP (если есть).

---

## Диагностика — быстрые проверки

1. **PSP vs наша БД**

   * В PSP: есть ли *две* подтверждённые транзакции? Если в PSP — да, значит деньги реально списались дважды.
   * Если в PSP — одна транзакция, а в БД — два заказа/записи — значит баг у нас (дублирование записи).
2. **Сравнить transaction_id / external_id**

   * Если два заказа с одинаковым PSP transaction_id → дублирование записи (мы не дедупируем по transaction id).
   * Если транзакции разные — реально два списания у PSP.
3. **Проверить Webhook/Callback**

   * Были ли повторные вебхуки от PSP? Были ли у нас 5xx/non-2xx ответы, мог ли PSP повторно отправить?
4. **Проверить UI/клиентские события**

   * Есть ли в логах два POST /checkout/confirm с разными request_id? Была ли многократная отправка (double click), пересылка form при reload?
5. **Проверить планировщик/cron**

   * Возможно: при оформлении создаётся заказ и параллельно планировщик подписок запустил создание ещё одного (например, автозапуск подписки сразу после оформления).
6. **Проверить тайминги 3DS / redirect flows**

   * Если 3DS — клиент вернулся в магазин и нажал повторно «Оплатить», а PSP разрешил второй charge.

---

## Как воспроизвести (список сценариев для staging - промежуточной среды)

Для каждого сценария — запускать с debug логированием + инспекцией PSP sandbox.

1. **Double-click / быстрый повторный submit**

   * На карточке/чекауте нажать кнопку «Оплатить» дважды или нажать → потерять связь → повторить.
   * Ожидаемый результат: один запрос на создание платежа / один idempotency key.

2. **Медленная сеть / reload во время ожидания**

   * Симулировать медленный ответ PSP (throttle) → пользователь перезагружает страницу и нажимает опять.

3. **Повторный webhook (webhook replay)**

   * Отправить webhook от PSP дважды (payload одинаковый) / отправить webhook с разницей в таймстемпе.
   * Проверить, обрабатывается ли повторение идемпотентно.

4. **Отказный ответ при первом webhook (5xx) → PSP повторяет → создаются 2 заказа**

   * Смоделировать временный 500 на наш endpoint при первом вызове.

5. **Race condition: checkout flow + cron**

   * Сделать заказ + одновременно запустить планировщик подписок, чтобы он попытался создать order для той же корзины.

6. **3DS redirect + повторная инициация**

   * Инициировать оплату требующую 3DS, перехватывать redirect и повторно инициировать оплату со стороны клиента.

7. **Стресс / параллельные запросы**

   * Отправить 5 параллельных POST /create-payment с одинаковыми параметрами — проверить, создались ли 5 транзакций.

8. **Mixed cart edge**

   * Корзина содержит подписку + разовый товар; проверить, не происходит ли двойной charge (один за «first order», второй — из подписки).

---

## Что смотреть в логах (специфично)

* Request id / correlation id (server + plugin + PSP).
* Тела запросов/ответов к PSP: payload, HTTP status, headers (особенно заголовки идемпотентности).
* Webhook timestamps и ответы (HTTP code, body).
* SQL-запросы в момент оформления — двойные insert? ошибки транзакций?
* Логика retry в коде оплаты: были ли автоповторы?

Пример полезных SQL-запросов (чтобы найти дубли):

```sql
-- найти заказы одного user с близким временем
SELECT ID, post_date, post_status
FROM wp_posts
WHERE post_type = 'shop_order' AND post_author = <user_id>
ORDER BY post_date DESC
LIMIT 20;

-- найти все мета по order с payment_tx_id
SELECT post_id, meta_key, meta_value
FROM wp_postmeta
WHERE meta_key LIKE '%transaction%' OR meta_key LIKE '%payment%';
```

---

## Чек-лист проверки корректности корзины и оплат (быстрый, для QA/DevOps)

(проходится вручную/автоматически; отмечаем PASS/FAIL)

1. Сбор данных от пользователя: OrderID(s), время, карта (last4). ✅
2. Проверка PSP Dashboard: количество транзакций по этому заказу/карте. ✅
3. Проверка наших логов: было ли >1 вызова createPayment / webhook / order creation. ✅
4. Проверить, совпадают ли PSP transaction_id и наша запись (мы не создаём второй order при одном transaction_id). ✅
5. Проверить идемпотентность webhook endpoint (повторный одинаковый payload → не создаёт второй order). ✅
6. Проверить поведение UI: после нажатия Pay кнопка блокируется, spinner, запросы с уникальным request_id. ✅
7. Проверка обработки 3DS flow: redirect→callback→не дублируется. ✅
8. Проверка cron/planner: нет одновременного создания order для уже оплаченного checkout. ✅
9. Проверка mixed cart: сумма и количество списаний корректны (single charge за first order). ✅
10. Проверить retry-логи платежей: не создавать новый заказ при retry, использовать статус update. ✅
11. Проверка, что транзакции помечаются external_transaction_id и есть уникальный индекс/проверка на дубли. ✅
12. Проверка мониторинга и алертов: отлавливаются необычные spikes количества транзакций. ✅

---

## Критерии оценки (как понять, что всё поправлено)

* При любых повторных запросах (double click, replay webhook, повторный callback) **не создаётся вторая успешная транзакция** у PSP и/или в БД не появляется второй paid order.
* Обработки повторных webhook'ов идемпотентны (по transaction_id / idempotency key).
* UI запрещает повторную отправку и показывает статус «ожидание оплаты».
* Журналируетcя correlation_id, и по нему можно однозначно связать событие в PSP и заказ в БД.
* Если деньги списаны дважды — на проде процесс возврата/compensation: refund через PSP + уведомление клиенту + тикет в support.

---

## Быстрые возможные причины и быстрые фиксы

1. **Отсутствие идемпотентности на уровне создания платежа** → *фикс*: использовать idempotency header (если поддерживает PSP) или серверную проверку по session/cart hash.
2. **Webhook replay / повторная обработка** → *фикс*: хранить processed_transaction_ids, игнорировать повторные.
3. **Double submit от UI** → *фикс*: disable button + debounce + client request_id.
4. **Race между checkout и cron** (подписки) → *фикс*: при создании заказа ставить флаг «in_progress»/блокировку, атомарно проверять наличие уже созданного order по cart_id/subscription_id.
5. **Плагин PSP создает два запроса (задержка + retry)** → *фикс*: логирование и использование idempotency / уникального reference в payload.

---

## Рекомендации по предотвращению в будущем (технический план)

1. Ввести **идемпотентные ключи** при вызове PSP (request header или внутренний payment_reference), и проверять их при обработке повторных запросов.
2. Сделать **уникальный индекс** по `payment_reference` / `psp_transaction_id` в таблице платежей, чтобы БД выбрасывала ошибку при дублировании и это логировалось.
3. Реализовать **серверную дедупликацию webhook'ов**: держать hash(payload) + timestamp и игнорировать повторы.
4. В UI: блокировка кнопки, явный индикатор «платёж в процессе», предотвращение повторной отправки формы.
5. Добавить **correlation_id** (сгенерировать на frontend и прокинуть в каждый запрос) — связывать все логи/запросы в цепочке.
6. Автоматизированные regression tests: сценарии double-click, webhook replay, slow network, cron race.
7. Мониторинг: метрики DuplicatePaymentAttempts, FailedWebhookRetries > threshold → алерты в Sentry/Prometheus.

---

## Шаблон уведомления клиенту (если деньги списаны дважды)

Коротко и по-делу:

1. Извинение + подтверждение факта (если подтверждено в PSP).
2. Объяснение: «техническая ошибка в обработке платежа» (без излишних деталей).
3. Действия: «Мы оформили возврат / инициировали возврат на карту. Ожидаемый срок — N банковских дней.»
4. Контакт поддержки и номер тикета.

---



<div style="display: flex; justify-content: space-between; align-items: center; margin: 2rem 0;">
  <!-- Previous Task Button -->
  <a href="/task/task-2" class="prev-task-button">
    <div style="display: flex; align-items: center; justify-content: center; width: 1.25rem; height: 1.25rem; border: 1px solid #f3f4f6; border-radius: 9999px; margin-right: 0.5rem;">
      <svg class="w-3 h-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
      </svg>
    </div>
    <p style="leading: none; margin: 0;">Задание №2</p>
  </a>

  <!-- Next Task Button -->
  <a href="/task/task-4" class="next-task-button">
    Задание №4
    <div style="display: flex; align-items: center; justify-content: center; width: 1.25rem; height: 1.25rem; border: 1px solid #f3f4f6; border-radius: 9999px; margin-left: 0.5rem;">
      <svg class="w-3 h-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
      </svg>
    </div>
  </a>
</div>
