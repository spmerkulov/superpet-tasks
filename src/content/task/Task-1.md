---
layout: ../../layouts/post.astro
title: Задание №1
description: Реализация подписки на корм (auto-order) с возможностью выбора товара, периодичности доставки и оплаты картой с автосписанием.
---

### ТЗ для разработчика
Представьте, что мы хотим внедрить новый функционал:
Подписка на корм (auto-order), где клиент может выбрать:
-товар (например, сухой корм, влажный корм),
-периодичность доставки (каждые 2, 4 или 8 недель), -оплату картой с автосписанием.

Задача:
-Составьте короткое, но структурированное техническое задание для разработчика (или команды), чтобы они поняли, как это должно работать.
-Включите: user flow (путь клиента), ключевые экраны, требования к корзине/чекауту, интеграцию с RetailCRM и способы тестирования.

ИЛИ 

-Пришлите любое ТЗ на другую схожую задачу, которое у вас уже готово и вы считаете, что прочитав разработчик сможет начать работу

---

## Краткий обзор

**Цель:** дать пользователю возможность оформить регулярную доставку корма (влажный/сухой) с периодичностью 2 / 4 / 8 недель и оплатой картой с автосписанием. Система должна автоматически создавать заказы, обрабатывать автоплатежи, синхронизироваться с RetailCRM и давать пользователю интерфейс управления подпиской.

---

## 1. User flow (путь клиента)

1. Клиент открывает карточку товара → видит опцию **«Купить разово / Подписка»**.
2. Клиент выбирает **Подписка**, указывает: упаковку/вариацию, периодичность (2/4/8 недель), первый платеж (сейчас) или отложенный старт (опционально), адрес доставки.
3. Клиент кладёт подписку в корзину — в корзине пометка «Подписка» + частота + дата следующей отгрузки.
4. На шаге оплаты выбирает **Карта (автосписание)** — проходит процесс привязки карты (токенизация у PSP - платёжный провайдер). Ставится согласие на автосписание (checkbox + ссылка на договор/политику).
5. После успешной оплаты — подписка создаётся, создаётся первый заказ (или заказ откладывается, если клиент выбрал отложенный старт).
6. Пользователь получает письма/SMS: подтверждение подписки, график доставок, уведомления при неудачной оплате.
7. В личном кабинете пользователь может: приостанавливать, менять частоту, менять адрес/количество, отменять подписку, пропускать ближайшую доставку, просматривать историю оплаченных/ожидающих заказов.

---

## 2. Ключевые экраны / элементы UI

**A. Карточка товара (Elementor)**

* Кнопка переключения: `Купить разово | Подписаться`
* Поля (при подписке): вариант товара, частота (radio: 2/4/8 нед.), старт (сейчас / дата), количество, краткое описание условий автоплатежа.
* Цена: показывать цену за единицу и пример ежемесячной суммы.

**B. Корзина**

* Подписки выделены (badge) + информация: частота, дата следующего отгрузки.
* Возможность редактировать частоту/кол-во там же (или ссылка в ЛК).

**C. Чекаут**

* Опция оплаты: `Карта (автосписание)` + другие способы (если есть).
* Обязательный чекбокс: согласие на автосписание + согласие на обработку персональных данных.
* Пояснение о токенизации карты и безопасности.
* Подтяжка адреса доставки и даты первой отправки.

**D. Личный кабинет — раздел «Мои подписки»**

* Список подписок с полями: статус (active/paused/cancelled), частота, следующая дата, количество, кнопки: `Приостановить/Возобновить`, `Изменить`, `Отменить`, `Пропустить доставку`.
* История платежей/следующие запланированные заказы.
* Детали: RetailCRM ID подписки, лог оплаты (последний статус).

**E. Админка WooCommerce**

* Карточка подписки (CPT - кастомный тип записи в WordPress, или запись плагина) с полями (см. модель ниже), логом попыток платежей, история синхронизации с RetailCRM, кнопка ручного форс-платежа/создания заказа.

---

## 3. Модель данных (Subscription object — обязательные поля)

* subscription_id (UUID)
* user_id (WP user ID)
* status: `active`, `paused`, `cancelled`, `pending_payment`
* product_id, variation_id
* quantity
* frequency_weeks: 2|4|8
* next_run_date (date)
* start_date
* payment_method: `card_autodebit`
* payment_token (токен от PSP) — **только если PSP разрешает**; иначе хранить reference-id
* retailcrm_subscription_id (если синхронизируем)
* retries_count, last_payment_status, last_payment_at
* created_at, updated_at

> Хранение персональных/платёжных данных — по правилам PSP/PCI и локальному законодательству. Хранить только токен/референс.

---

## 4. Логика бекенда / процессинг

1. **Создание подписки:** при успешной оплате/привязке карты сохраняется subscription, создаётся первый заказ (order) в WooCommerce и отправляется в RetailCRM.
2. **Планировщик (cron/queue):** ежедневно/каждый час проверяет подписки с next_run_date ≤ now → формирует заказ (создаёт WooCommerce order в статусе `processing`/`on-hold` в зависимости от логики), инициирует автоплатеж через PSP (если модель — платить при создании заказа), либо создаёт order с ожиданием оплаты.
3. **Платёж:** инициируем автосписание по сохранённому токену. Обработка ответов PSP: success → менять статус заказа, неуспех → retries (например, 3 попытки с интервалом), уведомления клиенту + флаг в RetailCRM.
4. **Обновление next_run_date:** после успешной оплаты/создания заказа next_run_date += frequency_weeks.
5. **Управление подпиской:** изменения в ЛК отражаются в subscription объекте и синхронизируются с RetailCRM (webhook/API).
6. **Отмена:** при отмене — перевод статуса и отправка события в RetailCRM. Опционально: сохранить действие как “cancel_reason”.

---

## 5. Требования к корзине / чекауту

* Корзина должна позволять смешивать подписки и разовые товары (при этом в checkout показывать чёткое разделение и, при необходимости, отдельные платежи).
* Если корзина содержит и разовые и подписные позиции, выбрать поведение:

  * **Вариант A (рекомендую):** объединять в один заказ, но автоплатеж будет регулярный для подписных строк; разовые позиции оплачиваются в первом заказе.
  * Чётко показать пользователю: «При оформлении будет списана сумма X — это оплата за первый заказ (включая разовые товары)».
* На чекауте: обязательное согласие на автосписание и ПДн. Показать условия отказа/изменения.
* Хранение и использование токенов: интегрироваться с PSP через токенизацию карт — **не** хранить raw PAN/CVV.

---

## 6. Интеграция с RetailCRM

**Цели интеграции:** иметь в RetailCRM события подписок, создавать/связывать заказы и контакты, отображать статус оплаты/следующую дату поставки.

**Точки синхронизации (события):**

* subscription.created → создать/обновить contact, создать custom entity `subscription` (если поддерживается) или поместить данные в customFields контакта/заказа; создать первый заказ в RetailCRM.
* subscription.updated (frequency, address, status) → обновление полей.
* subscription.cancelled → обновление статуса.
* order.created (automated) → создать заказ в RetailCRM (с флагом auto-order + ссылка на subscription_id).
* payment.success / payment.failed → обновление статуса платежа у соответствующего заказа/подписки.

**Требования к данным/поля:**

* contact: name, phone, email, address.
* order: items (sku, qty), delivery, payment (тип `card_autodebit`), externalId (Woo order ID), subscription_id.
* customFields (примерные): `subscription_frequency`, `subscription_next_date`, `subscription_status`, `subscription_id`.

**Техника интеграции:**

* Использовать RetailCRM REST API (ключ API, HTTPS).
* Реализовать retry/queue и логирование всех ответов.
* Для `webhook`/callback: настроить URL для получения статусов оплаты и/или событий RetailCRM (если используются вебхуки).
* Синхронизация должна быть идемпотентной (по externalId / subscription_id).

---

## 7. Платежный процесс (ключевые требования)

* Поддержка токенизации/автосписаний у локального PSP (РФ/СНГ). Обсудить конкретные PSP с Product Owner (важно: поддержка регулярных списаний без повторного ввода карты; 3DS (протокол защиты онлайн-платежей)/верификация при привязке).
* Хранить только токен/референс; не хранить PAN/CVV.
* Обработка ошибок: retries (например, 3 попытки с нарастающим интервалом), уведомления клиенту (email/SMS), перевод подписки в `pending_payment` при длительных ошибках.
* Юридически: на странице чекаута показывать согласие на автосписание и ссылку на публичную оферту/политику.

---

## 8. Тестирование (acceptance / QA)

**Среда:** отдельный staging с тестовыми ключами PSP и тестовой RetailCRM (sandbox). Тестировать на копии БД/товаров.

**Unit / Integration:**

* Покрыть автоматизацию создания подписки, формирования заказа, обновления next_run_date.
* Мок/симуляция ответа PSP (success, decline, network error).
* Мок RetailCRM API (успех/ошибка/тайм-аут).

**Manual сценарии (ключевые):**

1. Создание подписки (оплата успешна) → первый заказ создан + RetailCRM получил order & subscription.
2. Создание подписки с отложенным стартом → первый заказ — в нужную дату.
3. Автосписания через cron — успешное списание, создание заказа, next_run_date корректна.
4. Платёж отклонён → повторы, уведомления, отметки в RetailCRM.
5. Изменение частоты/адреса/кол-ва в ЛК → синхронизация в RetailCRM, корректная последующая дата.
6. Отмена подписки → отменённая в системе и в RetailCRM.
7. Сценарии с смешанной корзиной (подписка + разовый товар).
8. Масштаб: нагрузочное тестирование планировщика на N подписок/сутки (оценка времени создания заказов и запросов к PSP/RetailCRM).

**Тестовые карты:** использовать тестовые PAN, эмуляторы PSP; покрыть 3DS flows (процесс прохождения пользователем проверки 3D Secure: ввод карты → редирект на страницу банка → подтверждение → возврат на сайт.).

**Acceptance Criteria (коротко):**

* Подписка создаётся и появляется в ЛК + RetailCRM.
* Автоплатежи запускаются в соответствии с расписанием и корректно отмечаются в заказах.
* Пользователь может управлять подпиской (pause/change/cancel).
* Логи и retry механика при неудачных платежах.
* Безопасное хранение токенов и соответствующие пользовательские согласия.

---

## 9. API / webhooks (предложение основных эндпоинтов)

* `POST /api/subscriptions` — создать подписку (internal / from checkout).
* `GET /api/subscriptions/{id}` — получить.
* `PATCH /api/subscriptions/{id}` — изменить (частота, адрес, статус).
* `POST /webhooks/psp/payment` — обработка нотификаций PSP (payment success/fail).
* `POST /webhooks/retailcrm` — если RetailCRM шлёт колбеки (опционально).
* Cron job `/cron/subscriptions/run` (protected) — генерирует заказы для подписок с next_run_date ≤ now.

Каждый эндпоинт должен возвращать код и тело с подробностями ошибки и логироваться.

---

## 10. Замечания по безопасности и законодательству (коротко)

* Токенизировать карты у PSP; соблюдение PCI DSS / требований PSP.
* Согласие на обработку персональных данных и на автосписание обязательно (чекбокс + запись в логе).
* Локализация хранения персональных данных — проверить требования хранения в РФ (если требуется) и держать профиль соответствующим.

---

## 11. Deliverables для разработки

1. ТЗ + ER-модель subscription.
2. Реализация frontend: карточка товара, корзина, чекаут, ЛК.
3. Backend: модель подписки, планировщик, интеграция с PSP, интеграция с RetailCRM, API/webhooks.
4. Тесты (unit/integration) + инструкцию по запуску на staging.
5. Документация для поддержки: схема данных, webhook-ендпоинты, список ошибок и шаги восстановления.
6. План отката (если интеграция PSP/RCRM ломает процесс).

---

<div style="display: flex; justify-content: center; margin: 2rem 0;">
  <!-- Next Task Button -->
  <a href="/task/task-2" class="next-task-button">
    Задание №2
    <div style="display: flex; align-items: center; justify-content: center; width: 1.25rem; height: 1.25rem; border: 1px solid #f3f4f6; border-radius: 9999px; margin-left: 0.5rem;">
      <svg class="w-3 h-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
      </svg>
    </div>
  </a>
</div>
